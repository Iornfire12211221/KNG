import { z } from 'zod';
import { publicProcedure, createTRPCRouter } from '../../create-context';

// –°—Ö–µ–º—ã –≤–∞–ª–∏–¥–∞—Ü–∏–∏
const PostTypeSchema = z.enum(['dps', 'patrol', 'accident', 'camera', 'roadwork', 'animals', 'other']);
const PostSeveritySchema = z.enum(['low', 'medium', 'high']);

const CreatePostSchema = z.object({
  description: z.string(),
  latitude: z.number(),
  longitude: z.number(),
  address: z.string().optional(),
  landmark: z.string().optional(),
  timestamp: z.number(),
  expiresAt: z.number(),
  userId: z.string(),
  userName: z.string(),
  type: PostTypeSchema,
  severity: PostSeveritySchema,
  likes: z.number().default(0),
  likedBy: z.array(z.string()).default([]),
  photo: z.string().optional(),
  photos: z.array(z.string()).default([]),
  needsModeration: z.boolean().default(true),
  isRelevant: z.boolean().default(true),
  relevanceCheckedAt: z.number().optional(),
  // –ù–æ–≤—ã–µ –ø–æ–ª—è –¥–ª—è —É–ª—É—á—à–µ–Ω–Ω–æ–π –º–æ–¥–µ—Ä–∞—Ü–∏–∏
  roadType: z.enum(['HIGHWAY', 'CITY_ROAD', 'RESIDENTIAL', 'RURAL', 'BRIDGE', 'TUNNEL', 'INTERSECTION']).optional(),
  weather: z.enum(['CLEAR', 'CLOUDY', 'RAIN', 'SNOW', 'FOG', 'ICE', 'WIND', 'STORM']).optional(),
  trafficImpact: z.enum(['NONE', 'MINOR', 'MODERATE', 'MAJOR', 'SEVERE']).default('MINOR'),
  emergencyServices: z.boolean().default(false),
  casualties: z.number().min(0).default(0),
  accuracy: z.number().optional(),
});

export const postsRouter = createTRPCRouter({
  // –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –∞–∫—Ç–∏–≤–Ω—ã–µ –ø–æ—Å—Ç—ã (—Ç–æ–ª—å–∫–æ –æ–¥–æ–±—Ä–µ–Ω–Ω—ã–µ –¥–ª—è –æ–±—ã—á–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π)
  getAll: publicProcedure.query(async ({ ctx }) => {
    try {
      const now = Date.now();
      const posts = await ctx.prisma.post.findMany({
        where: {
          expiresAt: {
            gt: now
          },
          needsModeration: false // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –æ–¥–æ–±—Ä–µ–Ω–Ω—ã–µ –ø–æ—Å—Ç—ã
        },
        orderBy: {
          timestamp: 'desc'
        }
      });
      
      console.log(`üì• Fetched ${posts.length} approved posts from database`);
      return posts;
    } catch (error) {
      console.error('‚ùå Error fetching posts from database:', error);
      console.error('Error details:', {
        message: error instanceof Error ? error.message : 'Unknown error',
        stack: error instanceof Error ? error.stack : undefined,
      });
      throw error;
    }
  }),

  // –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –ø–æ—Å—Ç
  create: publicProcedure
    .input(CreatePostSchema)
    .mutation(async ({ input, ctx }) => {
      const post = await ctx.prisma.post.create({
        data: {
          ...input,
          timestamp: BigInt(input.timestamp),
          expiresAt: BigInt(input.expiresAt),
          relevanceCheckedAt: input.relevanceCheckedAt ? BigInt(input.relevanceCheckedAt) : null,
        }
      });
      
      console.log(`üì§ Created new post: ${post.id} by ${post.userName}`);
      return post;
    }),

  // –õ–∞–π–∫–Ω—É—Ç—å –ø–æ—Å—Ç
  like: publicProcedure
    .input(z.object({
      postId: z.string(),
      userId: z.string(),
    }))
    .mutation(async ({ input }) => {
      const post = await ctx.prisma.post.findUnique({
        where: { id: input.postId }
      });

      if (!post) {
        throw new Error('Post not found');
      }

      const likedBy = post.likedBy || [];
      const hasLiked = likedBy.includes(input.userId);

      const updatedPost = await ctx.prisma.post.update({
        where: { id: input.postId },
        data: {
          likes: hasLiked ? post.likes - 1 : post.likes + 1,
          likedBy: hasLiked 
            ? likedBy.filter(id => id !== input.userId)
            : [...likedBy, input.userId]
        }
      });

      console.log(`üëç Post ${input.postId} ${hasLiked ? 'unliked' : 'liked'} by ${input.userId}`);
      return updatedPost;
    }),

  // –£–¥–∞–ª–∏—Ç—å –ø–æ—Å—Ç
  delete: publicProcedure
    .input(z.object({
      postId: z.string(),
      userId: z.string(),
    }))
    .mutation(async ({ input }) => {
      const post = await ctx.prisma.post.findUnique({
        where: { id: input.postId }
      });

      if (!post) {
        throw new Error('Post not found');
      }

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –Ω–∞ —É–¥–∞–ª–µ–Ω–∏–µ (—Ç–æ–ª—å–∫–æ –∞–≤—Ç–æ—Ä –º–æ–∂–µ—Ç —É–¥–∞–ª–∏—Ç—å)
      if (post.userId !== input.userId) {
        throw new Error('Not authorized to delete this post');
      }

      await ctx.prisma.post.delete({
        where: { id: input.postId }
      });

      console.log(`üóëÔ∏è Post ${input.postId} deleted by ${input.userId}`);
      return { success: true };
    }),

  // –û—á–∏—Å—Ç–∏—Ç—å –ø—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω—ã–µ –ø–æ—Å—Ç—ã
  clearExpired: publicProcedure.mutation(async () => {
    const now = Date.now();
    const result = await ctx.prisma.post.deleteMany({
      where: {
        expiresAt: {
          lt: now
        }
      }
    });

    console.log(`üßπ Cleared ${result.count} expired posts`);
    return { deletedCount: result.count };
  }),

  // –£–¥–∞–ª–∏—Ç—å –í–°–ï –ø–æ—Å—Ç—ã (–¥–ª—è –ø–æ–ª–Ω–æ–π –æ—á–∏—Å—Ç–∫–∏)
  deleteAll: publicProcedure.mutation(async () => {
    try {
      const deletedCount = await ctx.prisma.post.deleteMany({});
      
      console.log(`üóëÔ∏è Deleted ALL ${deletedCount.count} posts from database`);
      return { deletedCount: deletedCount.count };
    } catch (error) {
      console.error('‚ùå Error deleting all posts:', error);
      throw error;
    }
  }),

  // –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –ø–æ—Å—Ç—ã –¥–ª—è –∞–¥–º–∏–Ω–æ–≤ (–≤–∫–ª—é—á–∞—è –Ω–∞ –º–æ–¥–µ—Ä–∞—Ü–∏–∏)
  getAllForAdmin: publicProcedure.query(async ({ ctx }) => {
    try {
      const now = Date.now();
      const posts = await ctx.prisma.post.findMany({
        where: {
          expiresAt: {
            gt: now
          }
          // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—Å–µ –ø–æ—Å—Ç—ã, –≤–∫–ª—é—á–∞—è –Ω–∞ –º–æ–¥–µ—Ä–∞—Ü–∏–∏
        },
        orderBy: {
          timestamp: 'desc'
        }
      });
      
      console.log(`üì• Fetched ${posts.length} posts for admin (including moderation)`);
      return posts;
    } catch (error) {
      console.error('‚ùå Error fetching posts for admin:', error);
      throw error;
    }
  }),

  // –ü–æ–ª—É—á–∏—Ç—å –ø–æ—Å—Ç—ã –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
  getByUserId: publicProcedure
    .input(z.object({ userId: z.string() }))
    .query(async ({ input }) => {
      try {
        const now = Date.now();
        const posts = await ctx.prisma.post.findMany({
          where: {
            userId: input.userId,
            expiresAt: {
              gt: now
            }
          },
          orderBy: {
            timestamp: 'desc'
          }
        });
        
        console.log(`üì• Fetched ${posts.length} posts for user ${input.userId}`);
        return posts;
      } catch (error) {
        console.error('‚ùå Error fetching posts for user:', error);
        throw error;
      }
    }),

  // –ü–æ–ª—É—á–∏—Ç—å –ø–æ—Å—Ç—ã –≤ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–π –æ–±–ª–∞—Å—Ç–∏ (–¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏)
  getInBounds: publicProcedure
    .input(z.object({
      northEast: z.object({
        latitude: z.number(),
        longitude: z.number(),
      }),
      southWest: z.object({
        latitude: z.number(),
        longitude: z.number(),
      }),
    }))
    .query(async ({ input }) => {
      // –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ–ø—Ç–∏–º–∏–∑–∞—Ç–æ—Ä –¥–ª—è –º–∞–ª–µ–Ω—å–∫–æ–≥–æ –≥–æ—Ä–æ–¥–∞
      const { SmallCityOptimizer } = await import('../../../../lib/small-city-optimizer');
      return await SmallCityOptimizer.getOptimizedPosts(input);
    }),

  // –ü–æ–ª—É—á–∏—Ç—å –ø–æ—Å—Ç—ã –Ω–∞ –º–æ–¥–µ—Ä–∞—Ü–∏–∏
  getPendingModeration: publicProcedure.query(async () => {
    try {
      const posts = await ctx.prisma.post.findMany({
        where: {
          moderationStatus: 'PENDING',
          needsModeration: true
        },
        orderBy: { timestamp: 'desc' },
        take: 20
      });
      
      console.log(`üì• Fetched ${posts.length} posts pending moderation`);
      return posts;
    } catch (error) {
      console.error('‚ùå Error fetching pending posts:', error);
      throw error;
    }
  }),

  // –†—É—á–Ω–∞—è –º–æ–¥–µ—Ä–∞—Ü–∏—è (–¥–ª—è –∞–¥–º–∏–Ω–æ–≤)
  moderate: publicProcedure
    .input(z.object({
      postId: z.string(),
      decision: z.enum(['PENDING', 'APPROVED', 'REJECTED', 'FLAGGED']),
      reason: z.string().optional(),
      moderatorId: z.string(),
    }))
    .mutation(async ({ input }) => {
      const post = await ctx.prisma.post.update({
        where: { id: input.postId },
        data: {
          moderationStatus: input.decision as any,
          moderationReason: input.reason,
          moderatedAt: BigInt(Date.now()),
          moderatedBy: input.moderatorId,
          needsModeration: input.decision === 'FLAGGED'
        }
      });

      console.log(`üëÆ Manual moderation: ${input.postId} -> ${input.decision} by ${input.moderatorId}`);
      return post;
    }),

  // –ó–∞–ø—É—Å—Ç–∏—Ç—å –ò–ò-–º–æ–¥–µ—Ä–∞—Ü–∏—é –¥–ª—è –≤—Å–µ—Ö –æ–∂–∏–¥–∞—é—â–∏—Ö
  runAIModeration: publicProcedure.mutation(async () => {
    try {
      const { EnhancedAIModeration } = await import('../../../../lib/enhanced-ai-moderation');
      await EnhancedAIModeration.moderatePendingPosts();
      return { success: true, message: 'AI moderation started' };
    } catch (error) {
      console.error('Error running AI moderation:', error);
      throw error;
    }
  }),

  // –ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –º–æ–¥–µ—Ä–∞—Ü–∏–∏
  getModerationStats: publicProcedure.query(async () => {
    try {
      const { EnhancedAIModeration } = await import('../../../../lib/enhanced-ai-moderation');
      const stats = await EnhancedAIModeration.getModerationStats();
      return stats;
    } catch (error) {
      console.error('Error getting moderation stats:', error);
      throw error;
    }
  }),

  // –ü–æ–ª—É—á–∏—Ç—å –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
  getOptimizedStats: publicProcedure.query(async () => {
    try {
      const { SmallCityOptimizer } = await import('../../../../lib/small-city-optimizer');
      return await SmallCityOptimizer.getOptimizedStats();
    } catch (error) {
      console.error('Error getting optimized stats:', error);
      throw error;
    }
  }),

  // –û—á–∏—Å—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –º–∞–ª–µ–Ω—å–∫–æ–≥–æ –≥–æ—Ä–æ–¥–∞
  cleanupForSmallCity: publicProcedure.mutation(async () => {
    try {
      const { SmallCityOptimizer } = await import('../../../../lib/small-city-optimizer');
      const result = await SmallCityOptimizer.cleanupForSmallCity();
      return result;
    } catch (error) {
      console.error('Error cleaning up for small city:', error);
      throw error;
    }
  }),

  // –ö–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏—è –ø–æ—Å—Ç–æ–≤
  clusterPosts: publicProcedure.mutation(async () => {
    try {
      const { SmallCityOptimizer } = await import('../../../../lib/small-city-optimizer');
      const clusters = await SmallCityOptimizer.clusterPostsForSmallCity();
      return { success: true, clusters };
    } catch (error) {
      console.error('Error clustering posts:', error);
      throw error;
    }
  }),

  // –ü–æ–ª—É—á–∏—Ç—å —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
  getOptimizationRecommendations: publicProcedure.query(async () => {
    try {
      const { SmallCityOptimizer } = await import('../../../../lib/small-city-optimizer');
      return SmallCityOptimizer.getOptimizationRecommendations();
    } catch (error) {
      console.error('Error getting optimization recommendations:', error);
      throw error;
    }
  }),
});
